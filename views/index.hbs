<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Stocking One Planner</title>
  <link rel="stylesheet" href="/public/css/styles.css">
</head>
<body class="bg-slate-100 h-screen flex flex-col">
  <!-- Corporate Header -->
  <div class="bg-slate-800 shadow-lg px-4 sm:px-6 lg:px-8 py-3 sm:py-4 flex justify-between items-center border-b-4 border-blue-600">
    <div class="flex items-center space-x-3 sm:space-x-4">
      <div class="w-10 h-10 sm:w-12 sm:h-12 bg-blue-600 rounded-lg flex items-center justify-center flex-shrink-0">
        <svg class="w-6 h-6 sm:w-7 sm:h-7 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"/>
        </svg>
      </div>
      <div>
        <h1 class="text-lg sm:text-2xl font-bold text-white tracking-wide">STOCKING ONE PLANNER</h1>
        <p class="text-xs sm:text-sm text-slate-300">Workforce Management System</p>
      </div>
    </div>
    <div class="flex items-center gap-2 sm:gap-4">
      <!-- Online/Offline Indicator -->
      <div id="connection-status" class="flex items-center gap-2 px-3 py-1.5 rounded-full bg-slate-700 border border-slate-600">
        <span id="status-dot" class="w-2.5 h-2.5 rounded-full bg-green-500"></span>
        <span id="status-text" class="text-xs sm:text-sm text-white font-medium">Online</span>
      </div>
      <button
        id="logout-button"
        class="bg-slate-700 hover:bg-slate-600 text-white font-medium py-2.5 px-4 sm:px-6 rounded border border-slate-600 transition duration-200 text-sm sm:text-base"
      >
        Sign Out
      </button>
    </div>
  </div>

  <!-- Main Content Area -->
  <div class="flex-1 bg-slate-50 p-4 sm:p-6 lg:p-8 overflow-y-auto">
      <div class="max-w-7xl mx-auto">
        <div class="mb-4 sm:mb-6 flex flex-col sm:flex-row justify-between items-start sm:items-center gap-3 sm:gap-0">
          <div>
            <h1 class="text-lg sm:text-xl lg:text-2xl font-bold text-slate-800 uppercase tracking-wide">Daily Work Plan</h1>
            <p class="text-xs sm:text-sm text-slate-600 mt-1">Task assignments and workforce allocation</p>
          </div>
          <button
            id="view-text-btn"
            class="bg-slate-700 hover:bg-slate-600 text-white font-semibold py-3 sm:py-2.5 px-4 sm:px-6 rounded shadow-sm transition duration-200 text-sm sm:text-base w-full sm:w-auto min-h-[48px]"
          >
            View as Text
          </button>
        </div>

        <!-- Progress Indicator -->
        <div id="progress-container" class="mb-4 sm:mb-6 bg-white rounded-lg shadow border border-slate-200 p-4 sm:p-6">
          <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-3 mb-3">
            <div>
              <h3 class="text-sm sm:text-base font-bold text-slate-800 uppercase tracking-wide">Task Coverage</h3>
              <p class="text-xs text-slate-600 mt-1">Required tasks must be assigned to at least one associate</p>
            </div>
            <div id="progress-badge" class="px-4 py-2 rounded-full font-semibold text-sm">
              <span id="progress-text">0 of 8 Required</span>
            </div>
          </div>

          <!-- Progress Bar -->
          <div class="w-full bg-slate-200 rounded-full h-3 sm:h-4 overflow-hidden">
            <div
              id="progress-bar"
              class="h-full transition-all duration-500 ease-out rounded-full"
              style="width: 0%"
            ></div>
          </div>

          <!-- Task Status Grid -->
          <div id="task-status-grid" class="mt-4 grid grid-cols-2 sm:grid-cols-4 lg:grid-cols-8 gap-2">
            <!-- Task badges will be inserted here -->
          </div>
        </div>

        <!-- Text View Section (hidden by default) -->
        <div id="text-view-section" class="hidden mb-4 sm:mb-6 bg-white rounded-lg shadow border border-slate-200 p-4 sm:p-6">
          <div class="flex justify-between items-center mb-3 sm:mb-4">
            <h2 class="text-base sm:text-lg font-semibold text-slate-800 uppercase tracking-wide">Text Format</h2>
            <button
              id="close-text-btn"
              class="text-slate-500 hover:text-slate-700 font-semibold text-sm py-2 px-3"
            >
              âœ• Close
            </button>
          </div>
          <textarea
            id="text-output"
            readonly
            class="w-full h-40 sm:h-64 p-3 sm:p-4 border-2 border-slate-300 rounded bg-slate-50 text-slate-800 font-mono text-xs sm:text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 resize-y"
          ></textarea>
          <button
            id="copy-text-btn"
            class="mt-3 bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 sm:py-2.5 px-4 rounded shadow-sm transition duration-200 text-sm sm:text-base w-full sm:w-auto"
          >
            ðŸ“‹ Copy to Clipboard
          </button>
        </div>

        <!-- Add Associate Section -->
        <div class="mb-4 sm:mb-6 bg-white rounded-lg shadow border border-slate-200 p-4 sm:p-6">
          <h2 class="text-base sm:text-lg font-semibold text-slate-800 uppercase tracking-wide mb-4">Add New Associate</h2>
          <div class="flex flex-col sm:flex-row gap-3">
            <input
              type="text"
              id="associate-input"
              placeholder="Enter associate name..."
              class="flex-1 px-4 py-3 border border-slate-300 rounded bg-white text-slate-700 placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
            />
            <button
              id="add-associate-btn"
              class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-6 rounded shadow-sm transition duration-200 whitespace-nowrap min-h-[48px]"
            >
              + Add Associate
            </button>
          </div>
        </div>

        <!-- Assignments Overview -->
        <div class="bg-white rounded-lg shadow border border-slate-200 overflow-hidden">
          <div class="bg-slate-800 text-white px-4 sm:px-6 py-3 sm:py-4 rounded-t-lg flex justify-between items-center">
            <h2 class="text-base sm:text-lg font-semibold uppercase tracking-wide">Current Assignments</h2>
            <div class="flex gap-2 sm:gap-3">
              <button
                id="quick-add-btn"
                class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-4 sm:px-5 rounded shadow-sm transition duration-200 text-xs sm:text-sm min-h-[48px]"
              >
                Quick Add
              </button>
              <button
                id="clear-table-btn"
                class="bg-red-600 hover:bg-red-700 text-white font-semibold py-3 px-4 sm:px-5 rounded shadow-sm transition duration-200 text-xs sm:text-sm min-h-[48px]"
              >
                Clear Table
              </button>
            </div>
          </div>
          <div id="assignments-overview" class="p-4 sm:p-6 overflow-x-auto">
            <p class="text-slate-500 italic text-sm">No associates added yet. Add an associate to get started.</p>
          </div>
        </div>
      </div>
  </div>

  <!-- Task Assignment Modal -->
  <div id="task-modal" class="fixed inset-0 bg-black bg-opacity-50 z-50 hidden flex items-end sm:items-center justify-center p-0 sm:p-4">
    <div class="bg-white rounded-t-3xl sm:rounded-lg shadow-2xl w-full sm:max-w-2xl max-h-[85vh] sm:max-h-[90vh] flex flex-col modal-bottom-sheet">
      <!-- Modal Header -->
      <div class="bg-slate-800 text-white px-6 py-5 sm:py-4 rounded-t-3xl sm:rounded-t-lg flex justify-between items-center border-b-4 border-blue-600 relative">
        <!-- Drag Handle for Mobile -->
        <div class="absolute top-2 left-1/2 transform -translate-x-1/2 w-12 h-1.5 bg-slate-600 rounded-full sm:hidden"></div>
        <h2 class="text-lg font-semibold uppercase tracking-wide">
          Assign Tasks to: <span id="modal-associate-name" class="text-blue-400 font-bold"></span>
        </h2>
        <button id="close-modal-btn" class="text-white hover:text-slate-300 transition">
          <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
          </svg>
        </button>
      </div>

      <!-- Modal Body -->
      <div class="p-6 overflow-y-auto flex-1">
        <div id="modal-task-list" class="space-y-2">
          <!-- Tasks will be dynamically added here -->
        </div>

        <!-- Custom Task Section -->
        <div class="mt-6 pt-6 border-t-2 border-slate-200">
          <h3 class="text-sm font-semibold text-slate-700 uppercase tracking-wide mb-3">Add Custom Task</h3>
          <div class="flex gap-2">
            <input
              type="text"
              id="custom-task-input"
              placeholder="Enter custom task description..."
              class="flex-1 px-4 py-2.5 border border-slate-300 rounded bg-white text-slate-700 placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent text-sm"
            />
            <button
              id="add-custom-task-btn"
              class="bg-green-600 hover:bg-green-700 text-white font-semibold py-3 px-5 rounded shadow-sm transition duration-200 text-sm whitespace-nowrap min-h-[48px]"
            >
              + Add
            </button>
          </div>
        </div>

        <!-- Custom Tasks List -->
        <div id="custom-tasks-container" class="mt-4 hidden">
          <h4 class="text-xs font-semibold text-slate-600 uppercase tracking-wide mb-2">Custom Tasks:</h4>
          <div id="custom-tasks-list" class="space-y-2">
            <!-- Custom tasks will be dynamically added here -->
          </div>
        </div>
      </div>

      <!-- Modal Footer -->
      <div class="bg-slate-50 px-6 py-4 sm:py-4 rounded-b-lg border-t border-slate-200 flex justify-end">
        <button id="done-modal-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-8 rounded shadow-sm transition duration-200 min-h-[48px]">
          Done
        </button>
      </div>
    </div>
  </div>

  <!-- Quick Add Modal -->
  <div id="quick-add-modal" class="fixed inset-0 bg-black bg-opacity-50 z-50 hidden flex items-end sm:items-center justify-center p-0 sm:p-4">
    <div class="bg-white rounded-t-3xl sm:rounded-lg shadow-2xl w-full sm:max-w-2xl max-h-[85vh] sm:max-h-[90vh] flex flex-col modal-bottom-sheet">
      <!-- Modal Header -->
      <div class="bg-slate-800 text-white px-6 py-5 sm:py-4 rounded-t-3xl sm:rounded-t-lg flex justify-between items-center border-b-4 border-blue-600 relative">
        <!-- Drag Handle for Mobile -->
        <div class="absolute top-2 left-1/2 transform -translate-x-1/2 w-12 h-1.5 bg-slate-600 rounded-full sm:hidden"></div>
        <h2 class="text-lg font-semibold uppercase tracking-wide">
          Quick Add Associates
        </h2>
        <button id="close-quick-add-btn" class="text-white hover:text-slate-300 transition">
          <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
          </svg>
        </button>
      </div>

      <!-- Modal Body -->
      <div class="p-6 overflow-y-auto flex-1">
        <p class="text-sm text-slate-600 mb-4">Select associates to add to your team:</p>
        <div id="quick-add-name-list" class="space-y-2">
          <!-- Names will be dynamically added here -->
        </div>
      </div>

      <!-- Modal Footer -->
      <div class="bg-slate-50 px-6 py-4 rounded-b-lg border-t border-slate-200 flex justify-end gap-3">
        <button id="cancel-quick-add-btn" class="bg-slate-600 hover:bg-slate-700 text-white font-semibold py-3 px-6 rounded shadow-sm transition duration-200 min-h-[48px]">
          Cancel
        </button>
        <button id="confirm-quick-add-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-6 rounded shadow-sm transition duration-200 min-h-[48px]">
          Add Selected
        </button>
      </div>
    </div>
  </div>

  <!-- Toast Notification Container -->
  <div id="toast-container" class="fixed top-4 right-4 z-[60] flex flex-col gap-2 pointer-events-none">
    <!-- Toasts will be dynamically added here -->
  </div>

  <style>
    /* Bottom Sheet Modal Animations */
    .modal-bottom-sheet {
      animation: slideUp 0.3s ease-out;
    }

    @keyframes slideUp {
      from {
        transform: translateY(100%);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }

    .modal-closing {
      animation: slideDown 0.25s ease-in forwards;
    }

    @keyframes slideDown {
      from {
        transform: translateY(0);
        opacity: 1;
      }
      to {
        transform: translateY(100%);
        opacity: 0;
      }
    }

    /* On desktop, fade in instead of slide */
    @media (min-width: 640px) {
      .modal-bottom-sheet {
        animation: fadeIn 0.2s ease-out;
      }

      .modal-closing {
        animation: fadeOut 0.2s ease-in forwards;
      }

      @keyframes fadeIn {
        from { opacity: 0; transform: scale(0.95); }
        to { opacity: 1; transform: scale(1); }
      }

      @keyframes fadeOut {
        from { opacity: 1; transform: scale(1); }
        to { opacity: 0; transform: scale(0.95); }
      }
    }

    /* Toast notification styles */
    .toast {
      pointer-events: auto;
      min-width: 300px;
      max-width: 500px;
      padding: 1rem 1.25rem;
      border-radius: 0.5rem;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      display: flex;
      align-items: center;
      gap: 0.75rem;
      animation: slideIn 0.3s ease-out;
      transition: all 0.3s ease;
    }

    .toast.removing {
      animation: slideOut 0.3s ease-out;
    }

    @keyframes slideIn {
      from {
        transform: translateX(400px);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    @keyframes slideOut {
      from {
        transform: translateX(0);
        opacity: 1;
      }
      to {
        transform: translateX(400px);
        opacity: 0;
      }
    }

    .toast-success {
      background-color: #10b981;
      color: white;
    }

    .toast-error {
      background-color: #ef4444;
      color: white;
    }

    .toast-warning {
      background-color: #f59e0b;
      color: white;
    }

    .toast-info {
      background-color: #3b82f6;
      color: white;
    }

    .toast-icon {
      flex-shrink: 0;
      width: 1.5rem;
      height: 1.5rem;
    }

    .toast-message {
      flex: 1;
      font-size: 0.875rem;
      font-weight: 500;
      line-height: 1.4;
    }

    .toast-close {
      flex-shrink: 0;
      width: 1.25rem;
      height: 1.25rem;
      cursor: pointer;
      opacity: 0.8;
      transition: opacity 0.2s;
    }

    .toast-close:hover {
      opacity: 1;
    }
  </style>

  <script>
    // JWT Authentication handling
    const token = localStorage.getItem('access_token') || sessionStorage.getItem('access_token');

    // Redirect to login if no token
    if (!token) {
      window.location.href = '/';
    }

    // Helper function to make authenticated API requests
    async function authenticatedFetch(url, options = {}) {
      const headers = {
        ...options.headers,
        'Authorization': `Bearer ${token}`,
      };

      const response = await fetch(url, { ...options, headers });

      // If unauthorized, redirect to login
      if (response.status === 401) {
        localStorage.removeItem('access_token');
        sessionStorage.removeItem('access_token');
        window.location.href = '/';
        throw new Error('Unauthorized');
      }

      return response;
    }

    // Haptic Feedback System
    function triggerHaptic(type = 'light') {
      // Check if the Vibration API is supported
      if ('vibrate' in navigator) {
        switch(type) {
          case 'light':
            // Light tap for selections, checkbox toggles
            navigator.vibrate(10);
            break;
          case 'medium':
            // Medium tap for button clicks, adds
            navigator.vibrate(20);
            break;
          case 'success':
            // Success pattern for completed actions
            navigator.vibrate([10, 50, 10]);
            break;
          case 'error':
            // Error pattern for failures
            navigator.vibrate([20, 100, 20, 100, 20]);
            break;
          case 'warning':
            // Warning pattern
            navigator.vibrate([15, 50, 15]);
            break;
        }
      }
    }

    // Toast Notification System
    function showToast(message, type = 'info', duration = 4000) {
      // Trigger haptic feedback based on toast type
      if (type === 'success') {
        triggerHaptic('success');
      } else if (type === 'error') {
        triggerHaptic('error');
      } else if (type === 'warning') {
        triggerHaptic('warning');
      }
      const toastContainer = document.getElementById('toast-container');

      // Create toast element
      const toast = document.createElement('div');
      toast.className = `toast toast-${type}`;

      // Icon based on type
      let icon = '';
      switch(type) {
        case 'success':
          icon = '<svg class="toast-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>';
          break;
        case 'error':
          icon = '<svg class="toast-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>';
          break;
        case 'warning':
          icon = '<svg class="toast-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path></svg>';
          break;
        case 'info':
          icon = '<svg class="toast-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>';
          break;
      }

      toast.innerHTML = `
        ${icon}
        <div class="toast-message">${message}</div>
        <svg class="toast-close" fill="none" stroke="currentColor" viewBox="0 0 24 24" onclick="this.parentElement.remove()">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
        </svg>
      `;

      // Add to container
      toastContainer.appendChild(toast);

      // Auto remove after duration
      setTimeout(() => {
        toast.classList.add('removing');
        setTimeout(() => {
          toast.remove();
        }, 300);
      }, duration);
    }

    // Logout functionality
    document.getElementById('logout-button').addEventListener('click', async () => {
      const logoutBtn = document.getElementById('logout-button');

      // Ask if they want to clear the table before signing out
      if (associates.length > 0) {
        const shouldClear = confirm('Would you like to clear the table before signing out?\n\nClick OK to clear the table, or Cancel to sign out without clearing.');

        if (shouldClear) {
          // Show loading state
          const originalText = logoutBtn.textContent;
          logoutBtn.disabled = true;
          logoutBtn.textContent = 'Clearing...';
          logoutBtn.classList.add('opacity-50', 'cursor-not-allowed');

          // Clear the table
          let successCount = 0;
          let failCount = 0;

          // Delete each associate from the database
          for (const associate of [...associates]) {
            try {
              const response = await authenticatedFetch(`/api/associates/${associate.id}`, {
                method: 'DELETE'
              });

              if (response.ok) {
                successCount++;
              } else {
                failCount++;
              }
            } catch (error) {
              console.error(`Failed to remove ${associate.name}:`, error);
              failCount++;
            }
          }

          // Show result if there were any failures
          if (failCount > 0) {
            showToast(`Cleared ${successCount} associate(s), but ${failCount} failed to remove.`, 'warning');
          } else if (successCount > 0) {
            showToast(`Cleared ${successCount} associate(s) successfully.`, 'success');
          }

          // Update button text for signing out
          logoutBtn.textContent = 'Signing Out...';
        } else {
          // Show loading state for sign out
          logoutBtn.disabled = true;
          logoutBtn.textContent = 'Signing Out...';
          logoutBtn.classList.add('opacity-50', 'cursor-not-allowed');
        }
      } else {
        // Show loading state for sign out
        logoutBtn.disabled = true;
        logoutBtn.textContent = 'Signing Out...';
        logoutBtn.classList.add('opacity-50', 'cursor-not-allowed');
      }

      // Sign out
      localStorage.removeItem('access_token');
      sessionStorage.removeItem('access_token');
      window.location.href = '/';
    });

    // Task list from tasks.txt
    const availableTasks = [
      "Paper, Pets, and Chemicals.",
      "New mod.",
      "Rollies.",
      "Automotive and Sporting goods.",
      "Housewares.",
      "Infants.",
      "Grocery and 95.",
      "Topsteel.",
      "Trailers.",
      "Scan early.",
      "Top Stock.",
      "Bikes, Crafts, Batteries, and Furniture.",
      "HBA and OTC."
    ];

    // Abbreviated task names for display in badges
    const taskAbbreviations = [
      "Paper, Pets, Chem",
      "New Mod",
      "Rollies",
      "Auto & Sporting",
      "Housewares",
      "Infants",
      "Grocery & 95",
      "Topsteel",
      "Trailers",
      "Scan Early",
      "Top Stock",
      "Bikes, Crafts, etc",
      "HBA & OTC"
    ];

    // Required tasks that must be assigned to at least one person
    // Task indices: 1, 2, 3, 4, 5, 6, 7, 12, 13 (0-indexed: 0, 1, 2, 3, 4, 5, 6, 11, 12)
    const requiredTaskIndices = [0, 1, 2, 3, 4, 5, 6, 11, 12];

    // Predefined names for Quick Add
    const predefinedNames = [
      "Lawrence",
      "Jay",
      "Heather",
      "Chris",
      "Jeff",
      "Michael",
      "Julia",
      "Ronnie",
      "Tawnya",
      "Dalton",
      "Michelle"
    ];

    // Associates management
    let associates = []; // Array of { id, name } objects from database
    let assignedTasks = {}; // { associateName: [{type: 'predefined', value: index} or {type: 'custom', value: 'task text', id: uniqueId}] }

    // Plan persistence
    let currentPlanId = null;
    let currentPlanDate = new Date().toISOString().split('T')[0]; // YYYY-MM-DD format
    let saveTimeout = null;

    const associateInput = document.getElementById('associate-input');
    const addBtn = document.getElementById('add-associate-btn');
    const assignmentsOverview = document.getElementById('assignments-overview');

    // Task Modal elements
    const taskModal = document.getElementById('task-modal');
    const modalAssociateName = document.getElementById('modal-associate-name');
    const modalTaskListContainer = document.getElementById('modal-task-list');
    const closeModalBtn = document.getElementById('close-modal-btn');
    const doneModalBtn = document.getElementById('done-modal-btn');

    // Custom task elements
    const customTaskInput = document.getElementById('custom-task-input');
    const addCustomTaskBtn = document.getElementById('add-custom-task-btn');
    const customTasksContainer = document.getElementById('custom-tasks-container');
    const customTasksList = document.getElementById('custom-tasks-list');

    let currentModalAssociateIndex = null;
    let customTaskIdCounter = 0;

    // Quick Add Modal elements
    const quickAddModal = document.getElementById('quick-add-modal');
    const quickAddBtn = document.getElementById('quick-add-btn');
    const quickAddNameList = document.getElementById('quick-add-name-list');
    const closeQuickAddBtn = document.getElementById('close-quick-add-btn');
    const cancelQuickAddBtn = document.getElementById('cancel-quick-add-btn');
    const confirmQuickAddBtn = document.getElementById('confirm-quick-add-btn');

    // Load associates from database
    async function loadAssociates() {
      try {
        const response = await authenticatedFetch('/api/associates');
        const data = await response.json();
        associates = data;
        associates.forEach(associate => {
          assignedTasks[associate.name] = [];
        });
        // Load today's plan after loading associates
        await loadTodaysPlan();
        updateAssignmentsOverview();
      } catch (error) {
        console.error('Failed to load associates:', error);
        if (error.message !== 'Unauthorized') {
          showToast('Failed to load associates from database', 'error');
        }
      }
    }

    // Plan persistence functions
    async function loadTodaysPlan() {
      try {
        const response = await authenticatedFetch(`/api/plans/by-date?date=${currentPlanDate}`);
        if (response.ok) {
          const plan = await response.json();
          if (plan) {
            currentPlanId = plan.id;
            assignedTasks = plan.assignments || {};
            // Ensure all current associates have entries
            associates.forEach(associate => {
              if (!assignedTasks[associate.name]) {
                assignedTasks[associate.name] = [];
              }
            });
            updateAssignmentsOverview();
            console.log('Loaded existing plan for today:', plan);
          }
        }
      } catch (error) {
        console.error('Failed to load today\'s plan:', error);
        // Non-critical error - continue with empty plan
      }
    }

    async function savePlan() {
      try {
        if (currentPlanId) {
          // Update existing plan
          const response = await authenticatedFetch(`/api/plans/${currentPlanId}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              assignments: assignedTasks
            })
          });
          if (response.ok) {
            console.log('Plan saved successfully');
          }
        } else {
          // Create new plan
          const response = await authenticatedFetch('/api/plans', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              planDate: currentPlanDate,
              assignments: assignedTasks
            })
          });
          if (response.ok) {
            const plan = await response.json();
            currentPlanId = plan.id;
            console.log('New plan created:', plan);
          }
        }
      } catch (error) {
        console.error('Failed to save plan:', error);
        // Don't show error toast - this is auto-save, not user-initiated
      }
    }

    function scheduleSave() {
      // Debounce saves to avoid too many API calls
      if (saveTimeout) {
        clearTimeout(saveTimeout);
      }
      saveTimeout = setTimeout(() => {
        savePlan();
      }, 1000); // Save 1 second after last change
    }

    // Modal Functions
    function openTaskModal(associateIndex) {
      triggerHaptic('medium');
      currentModalAssociateIndex = associateIndex;
      const associate = associates[associateIndex];

      // Set modal title
      modalAssociateName.textContent = associate.name;

      // Initialize task list in modal
      initializeModalTaskList(associateIndex);

      // Show modal
      taskModal.classList.remove('hidden');
      document.body.style.overflow = 'hidden';
    }

    function closeTaskModal() {
      const modalContent = taskModal.querySelector('.modal-bottom-sheet');
      modalContent.classList.add('modal-closing');

      setTimeout(() => {
        taskModal.classList.add('hidden');
        modalContent.classList.remove('modal-closing');
        document.body.style.overflow = '';
        currentModalAssociateIndex = null;
      }, 250);
    }

    function initializeModalTaskList(associateIndex) {
      const associate = associates[associateIndex];
      const currentTasks = assignedTasks[associate.name] || [];

      modalTaskListContainer.innerHTML = '';

      availableTasks.forEach((task, index) => {
        const taskDiv = document.createElement('div');
        taskDiv.className = 'flex items-center p-4 sm:p-5 bg-slate-50 border border-slate-200 rounded hover:bg-blue-50 hover:border-blue-300 transition cursor-pointer active:bg-blue-100 min-h-[56px]';

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `modal-task-${index}`;
        checkbox.value = index;
        // Check if this predefined task is assigned
        checkbox.checked = currentTasks.some(t => t.type === 'predefined' && t.value === index);
        checkbox.className = 'modal-task-checkbox w-7 h-7 sm:w-8 sm:h-8 text-blue-600 border-slate-300 rounded focus:ring-blue-500 focus:ring-2 flex-shrink-0 cursor-pointer';

        const label = document.createElement('label');
        label.htmlFor = `modal-task-${index}`;
        label.className = 'ml-3 text-sm text-slate-700 cursor-pointer flex-1 select-none font-medium';
        label.textContent = `${index + 1}. ${task}`;

        // Make the entire row clickable
        taskDiv.addEventListener('click', function(e) {
          if (e.target !== checkbox) {
            checkbox.checked = !checkbox.checked;
            handleModalTaskCheckboxChange(checkbox);
          }
        });

        checkbox.addEventListener('change', function() {
          handleModalTaskCheckboxChange(this);
        });

        taskDiv.appendChild(checkbox);
        taskDiv.appendChild(label);
        modalTaskListContainer.appendChild(taskDiv);
      });

      // Display existing custom tasks
      displayCustomTasks(associateIndex);

      // Clear custom task input
      customTaskInput.value = '';
    }

    function handleModalTaskCheckboxChange(checkbox) {
      if (currentModalAssociateIndex === null) return;

      // Haptic feedback for checkbox toggle
      triggerHaptic('light');

      const associate = associates[currentModalAssociateIndex];
      const taskIndex = parseInt(checkbox.value);

      if (checkbox.checked) {
        // Add predefined task
        const taskExists = assignedTasks[associate.name].some(
          t => t.type === 'predefined' && t.value === taskIndex
        );
        if (!taskExists) {
          assignedTasks[associate.name].push({ type: 'predefined', value: taskIndex });
        }
      } else {
        // Remove predefined task
        assignedTasks[associate.name] = assignedTasks[associate.name].filter(
          t => !(t.type === 'predefined' && t.value === taskIndex)
        );
      }

      // Update the table immediately
      updateAssignmentsOverview();
      scheduleSave();
    }

    function displayCustomTasks(associateIndex) {
      const associate = associates[associateIndex];
      const currentTasks = assignedTasks[associate.name] || [];
      const customTasks = currentTasks.filter(t => t.type === 'custom');

      customTasksList.innerHTML = '';

      if (customTasks.length > 0) {
        customTasksContainer.classList.remove('hidden');

        customTasks.forEach(task => {
          const taskDiv = document.createElement('div');
          taskDiv.className = 'flex items-center justify-between p-3 bg-green-50 border border-green-200 rounded';

          const taskText = document.createElement('span');
          taskText.className = 'text-sm text-slate-700 font-medium';
          taskText.textContent = task.value;

          const removeBtn = document.createElement('button');
          removeBtn.className = 'text-red-600 hover:text-red-800 font-semibold text-sm ml-2';
          removeBtn.textContent = 'âœ• Remove';
          removeBtn.onclick = () => removeCustomTask(task.id);

          taskDiv.appendChild(taskText);
          taskDiv.appendChild(removeBtn);
          customTasksList.appendChild(taskDiv);
        });
      } else {
        customTasksContainer.classList.add('hidden');
      }
    }

    function addCustomTask() {
      if (currentModalAssociateIndex === null) return;

      const customTaskText = customTaskInput.value.trim();
      if (!customTaskText) {
        showToast('Please enter a task description.', 'warning');
        return;
      }

      const associate = associates[currentModalAssociateIndex];
      const taskId = `custom-${customTaskIdCounter++}`;

      assignedTasks[associate.name].push({
        type: 'custom',
        value: customTaskText,
        id: taskId
      });

      // Update display
      displayCustomTasks(currentModalAssociateIndex);
      updateAssignmentsOverview();
      scheduleSave();

      // Clear input
      customTaskInput.value = '';
    }

    function removeCustomTask(taskId) {
      if (currentModalAssociateIndex === null) return;

      const associate = associates[currentModalAssociateIndex];
      assignedTasks[associate.name] = assignedTasks[associate.name].filter(
        t => !(t.type === 'custom' && t.id === taskId)
      );

      // Update display
      displayCustomTasks(currentModalAssociateIndex);
      updateAssignmentsOverview();
      scheduleSave();
    }

    // Custom task event listeners
    addCustomTaskBtn.addEventListener('click', addCustomTask);
    customTaskInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        addCustomTask();
      }
    });

    // Modal event listeners
    closeModalBtn.addEventListener('click', closeTaskModal);
    doneModalBtn.addEventListener('click', closeTaskModal);

    // Close modal when clicking outside
    taskModal.addEventListener('click', function(e) {
      if (e.target === taskModal) {
        closeTaskModal();
      }
    });

    // Quick Add Functions
    function openQuickAddModal() {
      triggerHaptic('medium');
      // Initialize the name list with checkboxes
      initializeQuickAddNameList();

      // Show modal
      quickAddModal.classList.remove('hidden');
      document.body.style.overflow = 'hidden';
    }

    function closeQuickAddModal() {
      const modalContent = quickAddModal.querySelector('.modal-bottom-sheet');
      modalContent.classList.add('modal-closing');

      setTimeout(() => {
        quickAddModal.classList.add('hidden');
        modalContent.classList.remove('modal-closing');
        document.body.style.overflow = '';
      }, 250);
    }

    function initializeQuickAddNameList() {
      quickAddNameList.innerHTML = '';

      // Get list of already added associate names
      const existingNames = associates.map(a => a.name.toLowerCase());

      predefinedNames.forEach((name, index) => {
        const nameDiv = document.createElement('div');
        const isAlreadyAdded = existingNames.includes(name.toLowerCase());

        nameDiv.className = `flex items-center p-4 sm:p-5 ${isAlreadyAdded ? 'bg-slate-100 opacity-50' : 'bg-slate-50 border border-slate-200 rounded hover:bg-blue-50 hover:border-blue-300 cursor-pointer active:bg-blue-100'} transition min-h-[56px]`;

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `quick-add-name-${index}`;
        checkbox.value = name;
        checkbox.disabled = isAlreadyAdded;
        checkbox.className = 'quick-add-checkbox w-7 h-7 sm:w-8 sm:h-8 text-blue-600 border-slate-300 rounded focus:ring-blue-500 focus:ring-2 flex-shrink-0 cursor-pointer';

        const label = document.createElement('label');
        label.htmlFor = `quick-add-name-${index}`;
        label.className = `ml-3 text-sm ${isAlreadyAdded ? 'text-slate-400 line-through' : 'text-slate-700'} cursor-pointer flex-1 select-none font-medium`;
        label.textContent = isAlreadyAdded ? `${name} (Already Added)` : name;

        if (!isAlreadyAdded) {
          // Make the entire row clickable
          nameDiv.addEventListener('click', function(e) {
            if (e.target !== checkbox) {
              checkbox.checked = !checkbox.checked;
            }
          });
        }

        nameDiv.appendChild(checkbox);
        nameDiv.appendChild(label);
        quickAddNameList.appendChild(nameDiv);
      });
    }

    async function confirmQuickAdd() {
      const selectedCheckboxes = document.querySelectorAll('.quick-add-checkbox:checked');
      const namesToAdd = Array.from(selectedCheckboxes).map(cb => cb.value);

      if (namesToAdd.length === 0) {
        showToast('Please select at least one associate to add.', 'warning');
        return;
      }

      // Show loading state
      const originalText = confirmQuickAddBtn.textContent;
      confirmQuickAddBtn.disabled = true;
      confirmQuickAddBtn.textContent = 'Adding...';
      confirmQuickAddBtn.classList.add('opacity-50', 'cursor-not-allowed');
      cancelQuickAddBtn.disabled = true;
      cancelQuickAddBtn.classList.add('opacity-50', 'cursor-not-allowed');

      try {
        // Add each selected name to the database
        let successCount = 0;
        let failCount = 0;

        for (const name of namesToAdd) {
          try {
            const response = await authenticatedFetch('/api/associates', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ name })
            });

            if (response.ok) {
              const newAssociate = await response.json();
              associates.push(newAssociate);
              assignedTasks[newAssociate.name] = [];
              successCount++;
            } else {
              failCount++;
            }
          } catch (error) {
            console.error(`Failed to add ${name}:`, error);
            failCount++;
          }
        }

        // Update the table
        updateAssignmentsOverview();

        // Close the modal
        closeQuickAddModal();

        // Show result
        if (successCount > 0) {
          if (failCount > 0) {
            showToast(`Added ${successCount} associate(s), but ${failCount} failed.`, 'warning');
          } else {
            showToast(`Successfully added ${successCount} associate(s)!`, 'success');
          }
        } else {
          showToast('Failed to add associates. Please try again.', 'error');
        }
      } finally {
        // Reset button states
        confirmQuickAddBtn.disabled = false;
        confirmQuickAddBtn.textContent = originalText;
        confirmQuickAddBtn.classList.remove('opacity-50', 'cursor-not-allowed');
        cancelQuickAddBtn.disabled = false;
        cancelQuickAddBtn.classList.remove('opacity-50', 'cursor-not-allowed');
      }
    }

    // Quick Add event listeners
    quickAddBtn.addEventListener('click', openQuickAddModal);
    closeQuickAddBtn.addEventListener('click', closeQuickAddModal);
    cancelQuickAddBtn.addEventListener('click', closeQuickAddModal);
    confirmQuickAddBtn.addEventListener('click', confirmQuickAdd);

    // Close modal when clicking outside
    quickAddModal.addEventListener('click', function(e) {
      if (e.target === quickAddModal) {
        closeQuickAddModal();
      }
    });

    // Clear Table Functionality
    const clearTableBtn = document.getElementById('clear-table-btn');

    async function clearTable() {
      if (associates.length === 0) {
        showToast('Table is already empty.', 'info');
        return;
      }

      if (!confirm(`Are you sure you want to remove all ${associates.length} associate(s) from the table? This action cannot be undone.`)) {
        return;
      }

      // Show loading state
      const originalText = clearTableBtn.textContent;
      clearTableBtn.disabled = true;
      clearTableBtn.textContent = 'Clearing...';
      clearTableBtn.classList.add('opacity-50', 'cursor-not-allowed');

      try {
        let successCount = 0;
        let failCount = 0;

        // Delete each associate from the database
        for (const associate of [...associates]) {
          try {
            const response = await authenticatedFetch(`/api/associates/${associate.id}`, {
              method: 'DELETE'
            });

            if (response.ok) {
              successCount++;
            } else {
              failCount++;
            }
          } catch (error) {
            console.error(`Failed to remove ${associate.name}:`, error);
            failCount++;
          }
        }

        // Clear local arrays
        associates = [];
        assignedTasks = {};

        // Update the table
        updateAssignmentsOverview();

        // Show result
        if (successCount > 0) {
          if (failCount > 0) {
            showToast(`Removed ${successCount} associate(s), but ${failCount} failed.`, 'warning');
          } else {
            showToast(`Successfully cleared ${successCount} associate(s)!`, 'success');
          }
        } else {
          showToast('Failed to clear table. Please try again.', 'error');
        }
      } finally {
        // Reset button state
        clearTableBtn.disabled = false;
        clearTableBtn.textContent = originalText;
        clearTableBtn.classList.remove('opacity-50', 'cursor-not-allowed');
      }
    }

    clearTableBtn.addEventListener('click', clearTable);

    // Update progress indicator
    function updateProgressIndicator() {
      const progressContainer = document.getElementById('progress-container');
      const progressBar = document.getElementById('progress-bar');
      const progressText = document.getElementById('progress-text');
      const progressBadge = document.getElementById('progress-badge');
      const taskStatusGrid = document.getElementById('task-status-grid');

      // Collect all assigned predefined task indices
      const allAssignedTasks = new Set();
      Object.values(assignedTasks).forEach(tasks => {
        tasks.forEach(task => {
          if (task.type === 'predefined') {
            allAssignedTasks.add(task.value);
          }
        });
      });

      // Count how many required tasks are assigned
      const assignedRequiredCount = requiredTaskIndices.filter(
        taskIndex => allAssignedTasks.has(taskIndex)
      ).length;

      const totalRequired = requiredTaskIndices.length;
      const percentage = (assignedRequiredCount / totalRequired) * 100;

      // Update progress bar
      progressBar.style.width = `${percentage}%`;

      // Color coding
      if (assignedRequiredCount === totalRequired) {
        progressBar.className = 'h-full transition-all duration-500 ease-out rounded-full bg-green-500';
        progressBadge.className = 'px-4 py-2 rounded-full font-semibold text-sm bg-green-100 text-green-800';
      } else if (assignedRequiredCount >= totalRequired * 0.6) {
        progressBar.className = 'h-full transition-all duration-500 ease-out rounded-full bg-yellow-500';
        progressBadge.className = 'px-4 py-2 rounded-full font-semibold text-sm bg-yellow-100 text-yellow-800';
      } else {
        progressBar.className = 'h-full transition-all duration-500 ease-out rounded-full bg-red-500';
        progressBadge.className = 'px-4 py-2 rounded-full font-semibold text-sm bg-red-100 text-red-800';
      }

      progressText.textContent = `${assignedRequiredCount} of ${totalRequired} Required`;

      // Update task status grid
      taskStatusGrid.innerHTML = '';
      requiredTaskIndices.forEach(taskIndex => {
        const isAssigned = allAssignedTasks.has(taskIndex);
        const badge = document.createElement('div');
        badge.className = `px-3 py-2 rounded text-xs font-semibold text-center ${
          isAssigned
            ? 'bg-green-100 text-green-800 border border-green-300'
            : 'bg-red-100 text-red-800 border border-red-300'
        }`;
        badge.textContent = taskAbbreviations[taskIndex];
        badge.title = availableTasks[taskIndex];
        taskStatusGrid.appendChild(badge);
      });

      // Show/hide progress container based on whether there are associates
      if (associates.length === 0) {
        progressContainer.classList.add('hidden');
      } else {
        progressContainer.classList.remove('hidden');
      }
    }

    // Update assignments overview display
    function updateAssignmentsOverview() {
      if (associates.length === 0) {
        assignmentsOverview.innerHTML = '<p class="text-slate-500 italic text-sm">No associates added yet. Add an associate to get started.</p>';
        updateProgressIndicator();
        return;
      }

      let tableHTML = `
        <table class="min-w-full">
          <thead>
            <tr class="border-b-2 border-slate-300">
              <th class="px-2.5 sm:px-6 py-2.5 sm:py-4 text-left text-xs font-bold text-slate-700 uppercase tracking-wider bg-slate-100 border-r border-slate-200">
                Associate Name
              </th>
              <th class="px-2.5 sm:px-6 py-2.5 sm:py-4 text-left text-xs font-bold text-slate-700 uppercase tracking-wider bg-slate-100 border-r border-slate-200">
                Assigned Tasks (Click to Edit)
              </th>
              <th class="px-2.5 sm:px-6 py-2.5 sm:py-4 text-center text-xs font-bold text-slate-700 uppercase tracking-wider bg-slate-100 w-24 sm:w-32">
                Actions
              </th>
            </tr>
          </thead>
          <tbody class="divide-y divide-slate-200">
      `;

      associates.forEach((associate, index) => {
        const tasks = assignedTasks[associate.name] || [];
        const tasksList = tasks.length > 0
          ? `<ul class="list-disc list-inside text-slate-700 space-y-1 sm:space-y-1.5">
              ${tasks.map(task => {
                if (task.type === 'predefined') {
                  return `<li class="text-xs sm:text-sm">${availableTasks[task.value]}</li>`;
                } else {
                  return `<li class="text-xs sm:text-sm"><span class="text-green-700 font-semibold">Custom:</span> ${task.value}</li>`;
                }
              }).join('')}
            </ul>`
          : '<span class="text-slate-400 italic text-xs sm:text-sm">No tasks assigned</span>';

        tableHTML += `
          <tr class="hover:bg-slate-50 transition">
            <td class="px-2.5 sm:px-6 py-2.5 sm:py-4 text-xs sm:text-sm font-semibold text-slate-800 border-r border-slate-200 bg-slate-50">
              ${associate.name}
            </td>
            <td class="px-2.5 sm:px-6 py-2.5 sm:py-4 text-xs sm:text-sm text-slate-700 cursor-pointer hover:bg-blue-50 transition border-r border-slate-200" data-associate-index="${index}" onclick="openTaskModal(${index})">
              ${tasksList}
            </td>
            <td class="px-2.5 sm:px-6 py-2.5 sm:py-4 text-center">
              <button
                onclick="removeAssociate(${index}, event)"
                class="bg-red-600 hover:bg-red-700 text-white font-semibold py-2 px-3 sm:px-4 rounded shadow-sm transition duration-200 text-xs sm:text-sm"
                title="Remove ${associate.name}"
              >
                Remove
              </button>
            </td>
          </tr>
        `;
      });

      tableHTML += `
          </tbody>
        </table>
      `;

      assignmentsOverview.innerHTML = tableHTML;
      updateProgressIndicator();
    }

    // Add associate
    addBtn.addEventListener('click', async () => {
      const name = associateInput.value.trim();
      if (!name) {
        showToast('Please enter a name!', 'warning');
        return;
      }

      // Check if associate already exists
      if (associates.some(a => a.name === name)) {
        showToast('Associate already exists!', 'warning');
        return;
      }

      // Show loading state
      const originalText = addBtn.textContent;
      addBtn.disabled = true;
      addBtn.textContent = 'Adding...';
      addBtn.classList.add('opacity-50', 'cursor-not-allowed');

      try {
        const response = await authenticatedFetch('/api/associates', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name })
        });

        if (!response.ok) {
          const error = await response.json();
          showToast(error.message || 'Failed to add associate', 'error');
          return;
        }

        const newAssociate = await response.json();
        associates.push(newAssociate);
        assignedTasks[newAssociate.name] = [];
        associateInput.value = '';
        updateAssignmentsOverview();
        showToast(`${newAssociate.name} added successfully!`, 'success');
      } catch (error) {
        console.error('Failed to add associate:', error);
        showToast('Failed to add associate to database', 'error');
      } finally {
        // Reset button state
        addBtn.disabled = false;
        addBtn.textContent = originalText;
        addBtn.classList.remove('opacity-50', 'cursor-not-allowed');
      }
    });

    // Remove associate
    async function removeAssociate(index, event) {
      const associate = associates[index];

      if (!confirm(`Are you sure you want to remove ${associate.name}?`)) {
        return;
      }

      // Show loading state on button
      const button = event ? event.target : null;
      if (button) {
        const originalText = button.textContent;
        button.disabled = true;
        button.textContent = 'Removing...';
        button.classList.add('opacity-50', 'cursor-not-allowed');
      }

      try {
        const response = await authenticatedFetch(`/api/associates/${associate.id}`, {
          method: 'DELETE'
        });

        if (!response.ok) {
          showToast('Failed to remove associate', 'error');
          if (button) {
            button.disabled = false;
            button.textContent = 'Remove';
            button.classList.remove('opacity-50', 'cursor-not-allowed');
          }
          return;
        }

        // Remove from local array
        associates.splice(index, 1);
        delete assignedTasks[associate.name];
        updateAssignmentsOverview();
        showToast(`${associate.name} removed successfully!`, 'success');
      } catch (error) {
        console.error('Failed to remove associate:', error);
        showToast('Failed to remove associate from database', 'error');
        if (button) {
          button.disabled = false;
          button.textContent = 'Remove';
          button.classList.remove('opacity-50', 'cursor-not-allowed');
        }
      }
    }

    // Allow Enter key to add associate
    associateInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        addBtn.click();
      }
    });

    // Load associates from database on page load
    loadAssociates();

    // Text view functionality
    const viewTextBtn = document.getElementById('view-text-btn');
    const closeTextBtn = document.getElementById('close-text-btn');
    const copyTextBtn = document.getElementById('copy-text-btn');
    const textViewSection = document.getElementById('text-view-section');
    const textOutput = document.getElementById('text-output');

    function generateTextFormat() {
      if (associates.length === 0) {
        return 'No associates added yet.';
      }

      let text = '';
      associates.forEach(associate => {
        const tasks = assignedTasks[associate.name] || [];
        text += `${associate.name}:\n`;

        if (tasks.length > 0) {
          tasks.forEach(task => {
            if (task.type === 'predefined') {
              text += `  - ${availableTasks[task.value]}\n`;
            } else {
              text += `  - [Custom] ${task.value}\n`;
            }
          });
        } else {
          text += `  (No tasks assigned)\n`;
        }
        text += '\n';
      });

      return text.trim();
    }

    function checkUnassignedRequiredTasks() {
      // Collect all assigned predefined task indices across all associates
      const allAssignedTasks = new Set();
      Object.values(assignedTasks).forEach(tasks => {
        tasks.forEach(task => {
          if (task.type === 'predefined') {
            allAssignedTasks.add(task.value);
          }
        });
      });

      // Find which required tasks are not assigned
      const unassignedRequired = requiredTaskIndices.filter(
        taskIndex => !allAssignedTasks.has(taskIndex)
      );

      return unassignedRequired;
    }

    viewTextBtn.addEventListener('click', () => {
      // Check for unassigned required tasks
      const unassigned = checkUnassignedRequiredTasks();

      if (unassigned.length > 0) {
        const unassignedTaskNames = unassigned.map(
          index => `  - Task ${index + 1}: ${availableTasks[index]}`
        ).join('\n');

        const warningMessage = `WARNING: The following required tasks are not assigned to anyone:\n\n${unassignedTaskNames}\n\nThese tasks must be assigned to at least one person.`;

        alert(warningMessage);
      }

      textOutput.value = generateTextFormat();
      textViewSection.classList.remove('hidden');
    });

    closeTextBtn.addEventListener('click', () => {
      textViewSection.classList.add('hidden');
    });

    copyTextBtn.addEventListener('click', async () => {
      try {
        await navigator.clipboard.writeText(textOutput.value);
        triggerHaptic('success');
        const originalText = copyTextBtn.textContent;
        copyTextBtn.textContent = 'âœ“ Copied!';
        copyTextBtn.classList.remove('bg-blue-600', 'hover:bg-blue-700');
        copyTextBtn.classList.add('bg-green-600', 'hover:bg-green-700');

        setTimeout(() => {
          copyTextBtn.textContent = originalText;
          copyTextBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
          copyTextBtn.classList.add('bg-blue-600', 'hover:bg-blue-700');
        }, 2000);
      } catch (err) {
        showToast('Failed to copy to clipboard', 'error');
      }
    });

    // ==========================================
    // OFFLINE SUPPORT & SERVICE WORKER
    // ==========================================

    // IndexedDB wrapper for offline storage
    const DB_NAME = 'stocking-planner-db';
    const DB_VERSION = 1;
    const STORE_NAME = 'pending-operations';

    let db = null;

    async function initDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);

        request.onerror = () => reject(request.error);
        request.onsuccess = () => {
          db = request.result;
          resolve(db);
        };

        request.onupgradeneeded = (event) => {
          const database = event.target.result;
          if (!database.objectStoreNames.contains(STORE_NAME)) {
            const store = database.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true });
            store.createIndex('timestamp', 'timestamp', { unique: false });
            store.createIndex('type', 'type', { unique: false });
          }
        };
      });
    }

    // Add operation to offline queue
    async function queueOfflineOperation(type, data) {
      if (!db) await initDB();

      return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);

        const operation = {
          type,
          data,
          timestamp: new Date().toISOString()
        };

        const request = store.add(operation);
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    }

    // Get all pending operations
    async function getPendingOperations() {
      if (!db) await initDB();

      return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.getAll();

        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    }

    // Remove operation from queue
    async function removeOperation(id) {
      if (!db) await initDB();

      return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.delete(id);

        request.onsuccess = () => resolve();
        request.onerror = () => reject(request.error);
      });
    }

    // Sync pending operations when online
    async function syncPendingOperations() {
      try {
        const operations = await getPendingOperations();

        for (const op of operations) {
          try {
            if (op.type === 'save-plan') {
              // Retry saving the plan
              await savePlan();
              await removeOperation(op.id);
              console.log('Synced operation:', op.id);
            }
          } catch (error) {
            console.error('Failed to sync operation:', op.id, error);
          }
        }

        if (operations.length > 0) {
          showToast('Synced offline changes', 'success');
        }
      } catch (error) {
        console.error('Failed to sync pending operations:', error);
      }
    }

    // Enhanced save function with offline support
    const originalSavePlan = savePlan;
    savePlan = async function() {
      try {
        await originalSavePlan();
      } catch (error) {
        // If offline, queue the operation
        if (!navigator.onLine) {
          await queueOfflineOperation('save-plan', {
            planId: currentPlanId,
            planDate: currentPlanDate,
            assignments: assignedTasks
          });
          console.log('Plan queued for offline sync');
        } else {
          throw error;
        }
      }
    };

    // Online/offline status monitoring
    let isOnline = navigator.onLine;
    const statusDot = document.getElementById('status-dot');
    const statusText = document.getElementById('status-text');

    function updateOnlineStatus() {
      const newStatus = navigator.onLine;

      // Update UI indicator
      if (newStatus) {
        statusDot.className = 'w-2.5 h-2.5 rounded-full bg-green-500 animate-pulse';
        statusText.textContent = 'Online';
      } else {
        statusDot.className = 'w-2.5 h-2.5 rounded-full bg-red-500 animate-pulse';
        statusText.textContent = 'Offline';
      }

      // Handle status change
      if (newStatus !== isOnline) {
        isOnline = newStatus;

        if (isOnline) {
          showToast('Back online - syncing changes...', 'success');
          syncPendingOperations();
          // Remove pulse after sync
          setTimeout(() => {
            statusDot.className = 'w-2.5 h-2.5 rounded-full bg-green-500';
          }, 3000);
        } else {
          showToast('You are offline - changes will sync when reconnected', 'warning');
        }
      }
    }

    // Set initial status
    updateOnlineStatus();

    window.addEventListener('online', updateOnlineStatus);
    window.addEventListener('offline', updateOnlineStatus);

    // Service Worker registration
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/public/service-worker.js')
          .then((registration) => {
            console.log('Service Worker registered:', registration.scope);

            // Check for updates
            registration.addEventListener('updatefound', () => {
              const newWorker = registration.installing;
              newWorker.addEventListener('statechange', () => {
                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                  // New service worker available
                  if (confirm('A new version is available! Reload to update?')) {
                    newWorker.postMessage({ type: 'SKIP_WAITING' });
                    window.location.reload();
                  }
                }
              });
            });
          })
          .catch((error) => {
            console.error('Service Worker registration failed:', error);
          });
      });
    }

    // Initialize offline support
    initDB().catch(error => {
      console.error('Failed to initialize IndexedDB:', error);
    });
  </script>
</body>
</html>
